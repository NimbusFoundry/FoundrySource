// Generated by CoffeeScript 1.8.0

/*
 core code
 */

(function() {
  var core;

  core = new Object();

  core._plugins = {};

  core._workspace = {};

  core._models = {};

  core.angular = {
    dependency: []
  };

  core.loaded = false;

  core.bootstraped = false;

  core.default_plugin = '';

  window.create_object_dictionary = function(all) {
    var dict, obj, _i, _len;
    dict = {};
    for (_i = 0, _len = all.length; _i < _len; _i++) {
      obj = all[_i];
      dict[obj.id] = obj;
    }
    return dict;
  };

  if (Nimbus.Client.GDrive.is_auth_redirected()) {
    $("#login_buttons").addClass("redirect");
  }

  core.current_user = function(callback) {
    var self;
    self = this;
    return Nimbus.Share.get_me(function(me) {
      console.log(me);
      self._current_user = me;
      if (!self._current_user.email) {
        self._current_user.email = Nimbus.Share.get_user_email();
      }
      if (callback) {
        callback(me);
      }
      $("#user_pic").attr("src", me.pic);
      return $("#user_pic_large").attr("src", me.pic);
    });
  };

  core.shared_users = function(callback) {
    var self;
    self = this;
    return Nimbus.Share.get_shared_users_real(function(users) {
      console.log(users);
      self._user_list = window.create_object_dictionary(users);
      if (callback) {
        return callback(users);
      }
    });
  };


  /*
   separate plugin loading form init process to accerate the app time
   */

  core.plugins_loaded = false;

  core.load_plugins = function() {
    var self;
    self = this;
    return require(['core'], function(main) {
      self.plugins_loaded = true;
      return require(main.plugins, function() {
        var dependency, plugin, _i, _len;
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          plugin = arguments[_i];
          self._plugins[plugin.name] = plugin;
        }
        dependency = self.angular.dependency.concat(['foundry-ui', 'ngRoute']);
        angular.module('foundry', dependency).config([
          '$routeProvider', function($routeProvider) {
            var path, route, _ref;
            _ref = main.paths;
            for (route in _ref) {
              path = _ref[route];
              $routeProvider.when('/' + route, {
                templateUrl: path + '.html'
              });
            }
          }
        ]).run([
          '$rootScope', '$location', function($rootScope, $location) {
            var inex, _plugin, _ref;
            $rootScope._plugins = [];
            _ref = foundry._plugins;
            for (inex in _ref) {
              _plugin = _ref[inex];
              $rootScope._plugins.push(_plugin);
            }
            $rootScope._active_app_path = '';
            $rootScope._current_global_user = foundry._current_user;
            $rootScope.$on('$locationChangeSuccess', function(evt, new_path, old_path) {
              var default_path;
              default_path = localStorage.default_plugin || foundry.default_plugin;
              if (default_path && !$location.path()) {
                $location.path(default_path);
              } else if (!$location.path()) {
                $location.path('/workspace');
              }
              $rootScope._active_app_path = $location.path();
              localStorage.default_plugin = $location.path();
            });
          }
        ]);
        console.log('plugins loaded');
        return self.plugin_load_completed();
      });
    });
  };

  define('core', ['config'], function(config) {
    var c, key, packages, paths, plugins, value, _ref;
    console.log(config);
    paths = {};
    plugins = [];
    packages = [];
    _ref = config.plugins;
    for (key in _ref) {
      value = _ref[key];
      paths[key] = value + '/index';
      plugins.push(key);
      packages.push({
        name: key,
        location: value,
        main: 'index'
      });
    }
    requirejs.config({
      'packages': packages
    });
    c = {
      'plugins': plugins,
      'paths': paths,
      'packages': packages,
      'appName': config.appName
    };
    return c;
  });

  core.plugin_load_completed = function() {
    return console.log('plugins is loaded');
  };

  core.init = function(callback) {
    var cb, plugin_completed, self;
    self = this;
    cb = function() {
      var key, value, _ref;
      self.init_settings();
      _ref = self._plugins;
      for (key in _ref) {
        value = _ref[key];
        if (typeof value.inited === 'function') {
          value.inited();
        }
      }
      if (!self.bootstraped) {
        angular.bootstrap(document, ['foundry']);
        self.bootstraped = true;
      }
      if (callback) {
        callback();
      }
    };
    if (this.plugins_loaded) {
      console.log('plugins loaded, and start the callback');
      this.reinitialize(cb);
    } else {
      console.log('not yet, put the callback into the plugin_callbak');
      plugin_completed = this.plugin_load_completed;
      this.plugin_load_completed = function() {
        plugin_completed();
        return self.reinitialize(cb);
      };
    }
  };

  core.module_status = {};

  core.reinitialize = function(callback) {
    var e, k, v, _ref, _ref1;
    if (callback) {
      this.module_finished = callback;
    }
    _ref = this._plugins;
    for (k in _ref) {
      v = _ref[k];
      if (v.type === 'plugin') {
        this.module_status[v.name] = 'start';
      }
    }
    _ref1 = this._plugins;
    for (k in _ref1) {
      v = _ref1[k];
      if (v.type === 'plugin') {
        try {
          v.init();
        } catch (_error) {
          e = _error;
          console.log(e);
        }
      }
    }
  };

  core.initialized = function(module) {
    var k, v, _ref;
    this.module_status[module] = 'end';
    console.log(this.module_status);
    _ref = this._plugins;
    for (k in _ref) {
      v = _ref[k];
      if (this.module_status[v.name] === 'start') {
        return;
      }
    }
    if (this.module_finished) {
      return this.module_finished();
    }
  };

  core.ready = function(callback) {
    var self;
    self = this;
    return Nimbus.Auth.set_app_ready(function() {
      callback();
      return self.loaded = true;
    });
  };

  core.model = function(name, attributes, callback) {
    var model, self, sync_finished;
    self = this;
    if (name && attributes) {
      model = Nimbus.Model.setup(name, attributes);
      self._models[name] = model;
      sync_finished = function() {
        return callback(model);
      };
      model.sync_all(sync_finished);
      return model;
    } else {
      throw 'Model name and attributes should be specified';
      return void 0;
    }
  };

  core.module = function(name, obj, callback) {
    var name_used;
    name_used = false;
    if (!core._plugins[name]) {
      core._plugins[name] = obj;
    } else {
      name_used = true;
    }
    callback(!name_used);
    return console.log('register ' + (!name_used ? 'ok' : 'failed'));
  };

  core.load = function(name) {
    return this._plugins[name];
  };

  core.load_model = function(name) {
    return this._models[name];
  };

  core.logout = function() {
    return Nimbus.Auth.logout();
  };


  /*
  	parse context within url
   */

  core.parse_open_url = function() {
    var config, e, m, open_setting, regex, string;
    config = {};
    string = decodeURIComponent(location.search.substring(1)).replace('/', '');
    regex = /([^&=]+)=([^&]*)/g;
    while (m = regex.exec(string)) {
      config[m[1]] = m[2];
    }
    if (config.state) {
      try {
        open_setting = JSON.parse(config.state);
        if (open_setting) {
          localStorage.login_user = open_setting.userId;
          if (open_setting.ids[0]) {
            localStorage.last_opened_workspace = open_setting.ids[0];
          }
        }
      } catch (_error) {
        e = _error;
        console.log(e);
      }
    } else if (config.space) {
      localStorage.last_opened_workspace = config.space;
      localStorage.to_open_topic = config.topic;
    }
    return config;
  };

  core.parse_open_url();


  /*
  	function: initialize the setting
   */

  core.init_settings = function() {
    return core.settings = core.model("Settings", ["userid", "setting_name", "setting_value"], function(model) {
      core.settings = model;
      return core._my_settings = model.findByAttribute("userid", core._current_user.id);
    });
  };


  /*
  	input: the key and the value to set
  	function: set the setting
   */

  core.set_setting = function(key, value) {
    var my_settings, x;
    my_settings = foundry.settings.select(function(item) {
      return item.userid === foundry._current_user.id && item.setting_name === key;
    });
    if (my_settings.length === 0) {
      return foundry.settings.create({
        "userid": foundry._current_user.id,
        "setting_name": key,
        "setting_value": value
      });
    } else {
      x = my_settings[0];
      x.setting_value = value;
      return x.save();
    }
  };


  /*
  	input: the key for the setting to retrieve
  	output: the value of the key
  	function: output a setting
   */

  core.get_setting = function(key) {
    var setting;
    setting = foundry.settings.select(function(item) {
      return item.userid === foundry._current_user.id && item.setting_name === key;
    });
    if (setting.length > 0) {
      return setting[0].setting_value;
    } else {
      return null;
    }
  };

  core.get_setting_all = function(userid, key) {
    var setting;
    setting = foundry.settings.select(function(item) {
      return item.userid === userid && item.setting_name === key;
    });
    if (setting.length > 0) {
      return setting[0].setting_value;
    } else {
      return null;
    }
  };

  core.set_file_public = function(id, callback) {
    var param;
    param = {
      body: {
        role: 'reader',
        type: 'anyone'
      },
      path: "/drive/v2/files/" + id + "/permissions",
      params: {
        fileId: id
      },
      method: "POST",
      callback: function(data) {
        log(data);
        if (callback) {
          return callback(data);
        }
      }
    };
    return gapi.client.request(param);
  };

  window.foundry = core;

}).call(this);
